---
description: Vertical Slice Architecture patterns and best practices
alwaysApply: false
---
# C# Vertical Slice Architecture

## Core Principles

1. **Self-contained**: Everything for a feature lives in one folder
2. **Shared code**: Only put in `Shared/` if 3+ features need it
3. **CQRS-lite**: Use `Command` suffix for write operations, `Query` suffix for read operations
4. **Shared DTOs**: Always prefer shared DTOs for common entities (User, Product, etc.)
5. **Value objects**: Use for domain concepts needing validation (Email, Username)
6. **Domain services**: Extract complex business logic spanning multiple entities
7. **Domain events**: Use for cross-feature communication

## Feature Structure

```
Features/{Group}/{FeatureName}/
├── {FeatureName}Request.cs
├── {FeatureName}Response.cs
├── {FeatureName}Command.cs      # Write operations (mutations)
├── {FeatureName}Query.cs        # Read operations
├── {FeatureName}Validator.cs (optional)
├── {FeatureName}Endpoint.cs
└── {FeatureName}Event.cs (optional)
```

## Shared DTOs

**Always use shared DTOs for common entities:**

```csharp
// Shared/Common/DTOs/UserDto.cs
public class UserDto
{
    public int Id { get; set; }
    public string Username { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
}

// In responses
public class RegisterUserResponse
{
    public string Token { get; set; } = string.Empty;
    public UserDto User { get; set; } = null!;  // Shared DTO
}

// In handlers
return ApiResult<RegisterUserResponse>.Success(new RegisterUserResponse
{
    Token = token,
    User = new UserDto { Id = user.Id, Username = user.Username.Value, Email = user.Email.Value }
});
```

## Value Objects

**Use for validated domain concepts:**

```csharp
// Create early in handler
Email email;
try { email = Email.Create(request.Email); }
catch (ArgumentException ex) { return ApiResult<Response>.ValidationError(ex.Message); }

// Use in entities
var user = new User { Email = email, Username = username };

// Access value
string emailString = user.Email.Value;
```

## Domain Services

**Extract complex business logic:**

```csharp
// Shared/Domain/Services/IUserDomainService.cs
Task<(bool CanRegister, string? ErrorMessage)> CanRegisterUserAsync(Username, Email, CancellationToken);
User CreateUser(Username, Email, string passwordHash, string passwordSalt);

// In handler
var (canRegister, errorMessage) = await _userDomainService.CanRegisterUserAsync(username, email);
if (!canRegister) return ApiResult<Response>.Conflict(errorMessage!);
```

## Domain Events

**Publish after successful operations:**

```csharp
// In feature folder
public record UserRegisteredEvent(int UserId, string Username, string Email) : IDomainEvent
{
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
}

// In handler
await _eventPublisher.PublishAsync(new UserRegisteredEvent(user.Id, user.Username.Value, user.Email.Value), cancellationToken);

// Handler (in Shared/ or feature folder)
public class UserRegisteredEventHandler : IDomainEventHandler<UserRegisteredEvent>
{
    public async Task HandleAsync(UserRegisteredEvent domainEvent, CancellationToken cancellationToken) { }
}
```

## CQRS-lite Pattern

**Commands** (write operations): `{FeatureName}Command`
**Queries** (read operations): `{FeatureName}Query`

```csharp
// Command example
public class RegisterUserCommand
{
    private readonly IUserDomainService _userDomainService;
    private readonly IUserRepository _userRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly IDomainEventPublisher _eventPublisher;

    public async Task<ApiResult<RegisterUserResponse>> HandleAsync(RegisterUserRequest request, CancellationToken cancellationToken = default)
    {
        // Create value objects
        Email email; Username username;
        try { email = Email.Create(request.Email); username = Username.Create(request.Username); }
        catch (ArgumentException ex) { return ApiResult<RegisterUserResponse>.ValidationError(ex.Message); }

        // Use domain service
        var (canRegister, errorMessage) = await _userDomainService.CanRegisterUserAsync(username, email, cancellationToken);
        if (!canRegister) return ApiResult<RegisterUserResponse>.Conflict(errorMessage!);

        // Business logic
        var user = _userDomainService.CreateUser(username, email, hash, salt);
        await _userRepository.AddAsync(user, cancellationToken);
        await _unitOfWork.SaveChangesAsync(cancellationToken);

        // Publish event
        await _eventPublisher.PublishAsync(new UserRegisteredEvent(user.Id, user.Username.Value, user.Email.Value), cancellationToken);

        // Return with shared DTO
        return ApiResult<RegisterUserResponse>.Success(new RegisterUserResponse
        {
            Token = token,
            User = new UserDto { Id = user.Id, Username = user.Username.Value, Email = user.Email.Value }
        });
    }
}

// Query example
public class GetCurrentUserQuery
{
    private readonly IUserRepository _userRepository;

    public async Task<ApiResult<GetCurrentUserResponse>> HandleAsync(int userId, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user == null) return ApiResult<GetCurrentUserResponse>.NotFound("User not found.");

        return ApiResult<GetCurrentUserResponse>.Success(new GetCurrentUserResponse
        {
            User = new UserDto { Id = user.Id, Username = user.Username.Value, Email = user.Email.Value }
        });
    }
}
```

## Endpoint Pattern

```csharp
[ApiController]
[Route("auth/register")]
public class RegisterUserEndpoint : ApiControllerBase
{
    private readonly RegisterUserCommand _handler;  // For write operations
    // OR
    private readonly GetCurrentUserQuery _handler;   // For read operations
    public RegisterUserEndpoint(RegisterUserCommand handler) => _handler = handler;

    [HttpPost]
    public async Task<IActionResult> Handle([FromBody] RegisterUserRequest request, CancellationToken cancellationToken)
    {
        var result = await _handler.HandleAsync(request, cancellationToken);
        return ToActionResult(result);
    }
}
```

## Service Registration

```csharp
// In ServiceCollectionExtensions
services.AddScoped<RegisterUserCommand>();  // Commands
services.AddScoped<GetCurrentUserQuery>();   // Queries
services.AddInfrastructureServices(); // Repositories, UnitOfWork
services.AddDomainServices();        // Domain services
services.AddDomainEvents();          // Event publisher
```

## Shared/ Structure

```
Shared/
├── Common/DTOs/          # Shared DTOs (UserDto, ProductDto)
├── Common/Interfaces/    # IUnitOfWork, IRepository
├── Common/Results/       # ApiResult
├── Domain/Entities/      # User, Product
├── Domain/ValueObjects/  # Email, Username
├── Domain/Services/      # IUserDomainService
└── Domain/Events/        # IDomainEvent, IDomainEventPublisher
```
