---
description: Vertical Slice Architecture patterns and best practices
alwaysApply: false
---
# C# Vertical Slice Architecture

## Core Principles

1. **Self-contained**: Everything for a feature lives in one folder
2. **Shared code**: Only put in `Shared/` if 3+ features need it
3. **Shared DTOs**: Always prefer shared DTOs for common entities (User, Product, etc.)
4. **Value objects**: Use for domain concepts needing validation (Email, Username)
5. **Domain services**: Extract complex business logic spanning multiple entities
6. **Domain events**: Use for cross-feature communication

## Feature Structure

```
Features/{Group}/{FeatureName}/
├── {FeatureName}Request.cs
├── {FeatureName}Response.cs
├── {FeatureName}Handler.cs
├── {FeatureName}Validator.cs (optional)
├── {FeatureName}Endpoint.cs
└── {FeatureName}Event.cs (optional)
```

## Shared DTOs

**Always use shared DTOs for common entities:**

```csharp
// Shared/Common/DTOs/UserDto.cs
public class UserDto
{
    public int Id { get; set; }
    public string Username { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
}

// In responses
public class RegisterUserResponse
{
    public string Token { get; set; } = string.Empty;
    public UserDto User { get; set; } = null!;  // Shared DTO
}

// In handlers
return ApiResult<RegisterUserResponse>.Success(new RegisterUserResponse
{
    Token = token,
    User = new UserDto { Id = user.Id, Username = user.Username.Value, Email = user.Email.Value }
});
```

## Value Objects

**Use for validated domain concepts:**

```csharp
// Create early in handler
Email email;
try { email = Email.Create(request.Email); }
catch (ArgumentException ex) { return ApiResult<Response>.ValidationError(ex.Message); }

// Use in entities
var user = new User { Email = email, Username = username };

// Access value
string emailString = user.Email.Value;
```

## Domain Services

**Extract complex business logic:**

```csharp
// Shared/Domain/Services/IUserDomainService.cs
Task<(bool CanRegister, string? ErrorMessage)> CanRegisterUserAsync(Username, Email, CancellationToken);
User CreateUser(Username, Email, string passwordHash, string passwordSalt);

// In handler
var (canRegister, errorMessage) = await _userDomainService.CanRegisterUserAsync(username, email);
if (!canRegister) return ApiResult<Response>.Conflict(errorMessage!);
```

## Domain Events

**Publish after successful operations:**

```csharp
// In feature folder
public record UserRegisteredEvent(int UserId, string Username, string Email) : IDomainEvent
{
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
}

// In handler
await _eventPublisher.PublishAsync(new UserRegisteredEvent(user.Id, user.Username.Value, user.Email.Value), cancellationToken);

// Handler (in Shared/ or feature folder)
public class UserRegisteredEventHandler : IDomainEventHandler<UserRegisteredEvent>
{
    public async Task HandleAsync(UserRegisteredEvent domainEvent, CancellationToken cancellationToken) { }
}
```

## Handler Pattern

```csharp
public class RegisterUserHandler
{
    private readonly IUserDomainService _userDomainService;
    private readonly IUserRepository _userRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly IDomainEventPublisher _eventPublisher;

    public async Task<ApiResult<RegisterUserResponse>> HandleAsync(RegisterUserRequest request, CancellationToken cancellationToken = default)
    {
        // Create value objects
        Email email; Username username;
        try { email = Email.Create(request.Email); username = Username.Create(request.Username); }
        catch (ArgumentException ex) { return ApiResult<RegisterUserResponse>.ValidationError(ex.Message); }

        // Use domain service
        var (canRegister, errorMessage) = await _userDomainService.CanRegisterUserAsync(username, email, cancellationToken);
        if (!canRegister) return ApiResult<RegisterUserResponse>.Conflict(errorMessage!);

        // Business logic
        var user = _userDomainService.CreateUser(username, email, hash, salt);
        await _userRepository.AddAsync(user, cancellationToken);
        await _unitOfWork.SaveChangesAsync(cancellationToken);

        // Publish event
        await _eventPublisher.PublishAsync(new UserRegisteredEvent(user.Id, user.Username.Value, user.Email.Value), cancellationToken);

        // Return with shared DTO
        return ApiResult<RegisterUserResponse>.Success(new RegisterUserResponse
        {
            Token = token,
            User = new UserDto { Id = user.Id, Username = user.Username.Value, Email = user.Email.Value }
        });
    }
}
```

## Endpoint Pattern

```csharp
[ApiController]
[Route("auth/register")]
public class RegisterUserEndpoint : ApiControllerBase
{
    private readonly RegisterUserHandler _handler;
    public RegisterUserEndpoint(RegisterUserHandler handler) => _handler = handler;

    [HttpPost]
    public async Task<IActionResult> Handle([FromBody] RegisterUserRequest request, CancellationToken cancellationToken)
    {
        var result = await _handler.HandleAsync(request, cancellationToken);
        return ToActionResult(result);
    }
}
```

## Service Registration

```csharp
// In ServiceCollectionExtensions
services.AddFeatureHandlers();      // Handlers
services.AddInfrastructureServices(); // Repositories, UnitOfWork
services.AddDomainServices();        // Domain services
services.AddDomainEvents();          // Event publisher
```

## Shared/ Structure

```
Shared/
├── Common/DTOs/          # Shared DTOs (UserDto, ProductDto)
├── Common/Interfaces/    # IUnitOfWork, IRepository
├── Common/Results/       # ApiResult
├── Domain/Entities/      # User, Product
├── Domain/ValueObjects/  # Email, Username
├── Domain/Services/      # IUserDomainService
└── Domain/Events/        # IDomainEvent, IDomainEventPublisher
```
