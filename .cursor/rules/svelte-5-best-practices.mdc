---
description: Svelte 5 best practices and patterns
alwaysApply: false
---
# Svelte 5 Best Practices

## Always Use Runes
```javascript
// ‚úÖ DO: Use Svelte 5 runes
let count = $state(0);
const doubled = $derived(count * 2);

// ‚ùå DON'T: Use legacy reactive statements
$: doubled = count * 2;
```

## State Management Patterns

### Use `$state` for Local Component State
```javascript
// ‚úÖ Good: Local component state
let isLoading = $state(false);
let selectedItem = $state(null);
let searchQuery = $state('');

// ‚ùå Avoid: Overusing stores for local state
// Use stores only for cross-component state
```

### Use `$state.raw` When Needed
```javascript
// ‚úÖ Use $state.raw for non-reactive objects
let person = $state.raw({
  name: 'Alice',
  age: 30
});

// ‚ùå Don't use $state.raw unnecessarily
let count = $state.raw(0); // Unnecessary, just use $state(0)
```

## Event Handling

### Use Modern Event Handlers
```javascript
// ‚úÖ Svelte 5: Direct property binding
<button onclick={handleClick}>Click me</button>

// ‚ùå Svelte 4: Old event directive
<button on:click={handleClick}>Click me</button>
```

### Handle Multiple Event Handlers Properly
```javascript
// ‚úÖ Combine multiple handlers correctly
<button onclick={(e) => {
  handleFirst(e);
  handleSecond(e);
}}>
  Click me
</button>
```

## Props and Components

### Use `$props` for Component Props
```javascript
// ‚úÖ Svelte 5 props
let { title, disabled = false, children } = $props();

// ‚ùå Svelte 4 export syntax
export let title;
export let disabled = false;
```

### Use `$bindable` for Two-Way Binding
```javascript
// ‚úÖ For two-way bound props
let { value = $bindable() } = $props();
```

## Effects and Lifecycle

### Use `$effect` Instead of `onMount`
```javascript
// ‚úÖ Svelte 5 effect
$effect(() => {
  if (data) {
    processData(data);
  }
});

// ‚ùå Svelte 4 onMount
onMount(() => {
  processData(data);
});
```

### Use `$effect.pre` for Pre-DOM Updates
```javascript
// ‚úÖ Pre-DOM effect for auto-scrolling
$effect.pre(() => {
  if (messages.length > 0) {
    scrollToBottom();
  }
});
```

## Performance Tips

### Avoid Unnecessary Re-renders
```javascript
// ‚úÖ Good: Stable references
const items = $derived.by(() => {
  return data.items.map(item => ({ ...item, computed: item.value * 2 }));
});

// ‚ùå Bad: New array every time
const items = $derived(data.items.map(item => ({ ...item, computed: item.value * 2 })));
```

### Use Proper Key Expressions
```javascript
<!-- ‚úÖ Use stable, unique keys -->
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}

<!-- ‚ùå Avoid index as key when possible -->
{#each items as item, index (index)}
  <div>{item.name}</div>
{/each}
```

### Use `@const` Wisely in Templates
```javascript
<!-- ‚úÖ GOOD: Use @const for multi-use variables -->
{@const isSelected = value === vracht.inkoop_vracht_nr}
{@const safeData = Array.isArray(data) ? data : []}
{@const computedValue = expensiveCalculation()}

<!-- ‚ùå BAD: Don't use @const for single-use variables -->
{@const rowClass = getRowClass(item)}
<TableRow class={`hover:bg-muted/50 ${rowClass}`}>

<!-- ‚úÖ BETTER: Inline single-use variables -->
<TableRow class={`hover:bg-muted/50 ${getRowClass(item)}`}>
```

**Rule of thumb:** Only use `@const` if the variable is used 2+ times or represents a complex computation! üéØ

## Code Organization

### Keep Components Small and Focused
```javascript
// ‚úÖ Single responsibility components
<PackageScanner {packages} onSelect={handleSelect} />
<PackageTable {packages} selectedId={selectedId} />
<PackageActions {selectedPackage} onAction={handleAction} />

// ‚ùå Monolithic components
<PackageManager /> <!-- Does everything -->
```

### Use Snippets for Reusable Markup
```javascript
<!-- ‚úÖ Use snippets for reusable templates -->
{#snippet packageRow(package)}
  <tr class="border-b">
    <td>{package.id}</td>
    <td>{package.name}</td>
    <td>{package.status}</td>
  </tr>
{/snippet}

{#each packages as package}
  {@render packageRow(package)}
{/each}
```

## TypeScript Integration

### Use Proper TypeScript in Svelte
```typescript
<script lang="ts">
  let count: number = $state(0);
  let items: Package[] = $state([]);

  const selectedItem = $derived.by((): Package | null => {
    return items.find(item => item.id === selectedId) ?? null;
  });

  function handleSelect(id: string): void {
    selectedId = id;
  }
</script>
```

### Type Component Props
```typescript
<script lang="ts">
  interface Props {
    packages: Package[];
    selectedId?: string;
    onSelect: (id: string) => void;
  }

  let { packages, selectedId, onSelect }: Props = $props();
</script>
```

### Avoid Prop drilling
```javascript
// ‚úÖ Good: Avoid prop drilling
<PackageScanner {packages} onSelect={handleSelect} />
<PackageTable {packages} selectedId={selectedId} />
<PackageActions {selectedPackage} onAction={handleAction} />

// ‚ùå Bad: Prop drilling
<PackageManager {packages} selectedId={selectedId} onSelect={handleSelect} onAction={handleAction} />
```
If you need to pass a lot of props, consider using a context or a store.